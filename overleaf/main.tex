\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage{tikz,tikz-3dplot} 
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\geometry{a4paper, margin=2.5cm}
\setlength { \parskip }{0.3\baselineskip }

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=black
}


%=======================================================
%  INDIQUE AQUI O NOME DO PROBLEMA E A EQUIPE 
%=======================================================
\title{Universidade Federal de Juiz de Fora \\
        DCC059 - Teoria dos Grafos \\
        \vspace{6.0cm}
        {\Huge\textbf{L(p, q)-coloring}}\\
        \vspace{6.0cm}
}
\author{
    Deyvison Otaviano Fernandes - 201976016 \\
    Hugo Ricardo Giles Nicolau - 202435003 \\
    Lucas Duan Rodrigues - 202576010 \\
    Rafael Müller dos Santos Moreira - 202465557C \\
    Thaíse Silva Alves - 202435038 \\
}
\date{Janeiro de 2026}





%=======================================================
%=======================================================
\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

%=======================================================
%                 I N T R O D U Ç Ã O
%=======================================================
\section{Introdução}
O presente relatório tem como objetivo apresentar o desenvolvimento, a implementação e a análise experimental de algoritmos para o problema de coloração $L(p, q)$ em grafos. Considerou-se neste trabalho as características do problema onde a atribuição de cores (rótulos inteiros) aos vértices deve respeitar restrições de distância: vértices adjacentes precisam ter cores com diferença mínima $p$, enquanto vértices a distância 2 devem ter cores com diferença mínima $q$. No contexto da disciplina de Teoria dos Grafos, este projeto visa explorar a aplicação de meta-heurísticas em problemas de otimização combinatória NP-difíceis. A motivação reside na importância prática desse problema, frequentemente associado ao design de redes sem fio e à alocação de frequências, onde a interferência deve ser minimizada respeitando a proximidade geográfica dos dispositivos. Foram desenvolvidos três algoritmos construtivos: um algoritmo guloso (GreedyAlgorithm), um randomizado baseado em GRASP (GRASPAlgorithm) e um reativo (ReactiveGRASPAlgorithm), que foram avaliados sobre um conjunto de instâncias no formato DIMACS e os resultados foram comparados com os apresentados em trabalhos clássicos da literatura sobre o número de canal (span) para coloração de distância.

O restante do trabalho está assim estruturado: na Seção \ref{secProblema} o problema é descrito formalmente através de um modelo em grafos; a Seção \ref{secAlgoritmos} descreve as abordagens propostas para o problema, enquanto a Seção \ref{secResultados} apresenta os experimentos computacionais, onde se descreve o design dos experimentos, o conjunto de instâncias (\textit{benchmarks}), bem como se apresenta a análise comparativa dos resultados dos algoritmos desenvolvidos e a literatura; por fim, a Seção \ref{secConclusoes} traz as conclusões do trabalho e propostas de trabalhos futuros.



%=======================================================
%     D E S C R I Ç Ã O     D O    P R O B L E M A
%=======================================================
\section{Descrição do Problema}
\label{secProblema}
Dado um grafo não direcionado $G = (V, E)$, o problema da coloração $L(p, q)$ consiste em atribuir um rótulo (cor) inteiro não negativo $c(v)$ a cada vértice $v \in V$. O objetivo é minimizar a maior cor utilizada (o span da coloração), respeitando restrições de distância entre os vértices para evitar interferências.O problema pode ser formulado formalmente por:

Função objetivo:\begin{equation}\min \lambda = \max_{v \in V} {c(v)} \label{func_obj_lpq}\end{equation}

Sujeito a:

\begin{equation}|c(u) - c(v)| \geq p, \quad \text{se } d(u, v) = 1 \label{restr_p}\end{equation}

\begin{equation}|c(u) - c(v)| \geq q, \quad \text{se } d(u, v) = 2 \label{restr_q}\end{equation}

\begin{equation}c(v) \in {0, 1, 2, \dots, \lambda}, \quad \forall v \in V \label{restr_cor}\end{equation}

A função objetivo (\ref{func_obj_lpq}) busca minimizar o valor $\lambda$, que representa a maior cor atribuída no grafo. A restrição (\ref{restr_p}) estabelece que vértices adjacentes (distância $d=1$) devem possuir cores com uma diferença absoluta de pelo menos $p$. A restrição (\ref{restr_q}) impõe que vértices separados por exatamente dois saltos (distância $d=2$) possuam cores com diferença absoluta de pelo menos $q$. Por fim, a restrição (\ref{restr_cor}) define o domínio das cores como números inteiros não negativos.

\textbf{Observação:} estas equações são apenas um exemplo. Você não precisa descrever o problema na forma de Programação Matemática, mas é essencial que o problema seja descrito formalmente através de  modelagem em grafos.

Ilustre sempre que possível e, sempre que inserir uma figura ou tabela, escreva algo que a explique. Como é possível observar na Figura \ref{fig:exemplo-imagem}, $\dots$.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{img/Grafo-konigsberg.jpg} % substitua pelo nome do arquivo da sua imagem
    \caption{Essa figura é um arquivo jpg  (Fonte: \cite{} - indique quem fez a figura)}
    \label{fig:exemplo-imagem}
\end{figure}

Se preferir, desenhe os grafos da instância e de uma solução para ilustrar melhor o problema.

\begin{figure}[ht!]
  \label{fig:acima}
  \centering
  
  \begin{subfigure}{0.95\textwidth}
    \centering
    \input{img/grafo1}
    \caption{Instância desenhada no arquivo grafo1 }
    \label{fig:grafo1}
  \end{subfigure}
  
\vspace{1cm} % espaço vertical de 1cm entre figura de cima e as de baixo
  \begin{subfigure}{0.45\textwidth}
    \centering
    % use resizebox se precisar reduzir ou aumentar uma figura
    \resizebox{0.9\textwidth}{!}{ 
    \input{img/grafo2}
    }
    \caption{Solução do arquivo grafo2}
    \label{fig:grafo2}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.45\textwidth}
    \centering
    % use resizebox se precisar reduzir ou aumentar uma figura
    \resizebox{0.9\textwidth}{!}{
    \input{img/grafo3}
    }
    \caption{Outra solução do arquivo grafo3}
    \label{fig:grafo2-ladoalado}
  \end{subfigure}
  
  \caption{Exemplo do problema XXX }
\end{figure}

Os exemplos de grafos incluídos nos arquivos têm estilos diferentes para ilustrar diferentes possibilidades, caso queiram utilizar esse recurso. Outros exemplos de grafos podem ser encontrados em \href{https://tikz.net}{Tikz.net} ou em \href{https://texample.net}{TeXample.net}.



%=======================================================
%                 A L G O R I T M O S
%=======================================================
\section{Algoritmos Implementados}
\label{secAlgoritmos}

Nesta seção são detalhados os algoritmos propostos para a obtenção de soluções para o problema xyz.
É importante que os algoritmos sejam apresentados de forma detalhada, de forma que seja possível que qualquer pessoa consiga reproduzir os algoritmos propostos. 

\subsection{Algoritmo Guloso}
\label{subSecAlgGuloso}


O algoritmo guloso implementa uma heurística determinística baseada na ordenação dos vértices do grafo por grau em ordem decrescente. Assim, são processados primeiro os vértices com mais conexões. Essa escolha se baseia na observação de que vértices com mais vizinhos são mais difíceis de se atribuir uma cor e devem ser visitados primeiro, quando há mais flexibilidade na escolha de cores. O contrário ocorre com vértices de menor grau, nos quais há menos restrições para escolha de cores. Na execução do algoritmo, começamos com cor 1 e iteramos sobre os vizinhos, procurando vértices que invalidem a regra de coloração L(P,Q), incrementando a cor do vértice atual até que a condição seja respeitada para todos os vizinhos de distância 1, para diferenças de no máximo P, e vizinhos de distância 2, para diferenças de no máximo Q.

\begin{algorithm}[H]
\caption{Algoritmo Guloso}
\label{algGuloso}
\KwIn{Grafo \( G = (V, E) \), parâmetros \( p, q \)}
\KwOut{Coloração válida \( c: V \rightarrow \mathbb{Z}^+ \)}

Inicialize \( c(v) \leftarrow 0 \) para todo \( v \in V \)\\
Ordene os vértices por grau em ordem decrescente: \( ordem \leftarrow \text{sort}(V, \text{grau}) \)\\

\For{vértices \( v \in ordem \)}{
    \( cor \leftarrow 1 \)\\
    \( coloracaoValida \leftarrow \text{falso} \)\\
    
    \While{\( \neg coloracaoValida \)}{
        \( coloracaoValida \leftarrow \text{verdadeiro} \)\\
        
        \tcp{Verificação da restrição de P}
        \For{vértice \( u \in N(v) \) com \( c(u) \neq 0 \)}{
            \If{\( |cor - c(u)| < p \)}{
                \( coloracaoValida \leftarrow \text{falso} \)\\
                \textbf{break}\\
            }
        }
        
        \If{\( coloracaoValida \)}{
            \tcp{Verificação da restrição de Q}
            \For{vértice \( u \in N_2(v) \) com \( c(u) \neq 0 \)}{
                \If{\( |cor - c(u)| < q \)}{
                    \( coloracaoValida \leftarrow \text{falso} \)\\
                    \textbf{break}\\
                }
            }
        }
        
        \If{\( \neg coloracaoValida \)}{
            \( cor \leftarrow cor + 1 \)\\
        }
    }
    
    \( c(v) \leftarrow cor \)\\
}

\Return{\( c \)}
\end{algorithm}

A abordagem de algoritmo guloso garante um velocidade muito grande, e também boa eficiência quando o grafo possui um estrutura hierárquica aparente, com vértices de maior grau e outros de menor grau, além da execução determinística. Porém, em grafos mais complexos, a minimização local realizada pelo algoritmo não implica em minimização global e pode colorir um vértice de uma cor de tal forma que prejudique a solução posteriormente à fase de busca local, característica chamada de miopia algorítmica; tal fato é atenuado em grafos esparsos. Para grafos regulares ou quase regulares, o algoritmo também perde eficiência pois a heurística não pode ser empregada, e os índices dos vértices são utilizados como critério de desempate, o que pode levar a colorações erráticas e aparentemente aleatórias. Por fim, o grafo não reconhece o caráter k-partido de alguns grafos, podendo fazer uma coloração ineficiente nesses casos.

Portanto, o algoritmo guloso é recomendado como primeira abordagem para estabelecer um referencial de qualidade e tempo. É eficaz em grafos esparsos ou com estrutura hierárquica clara de graus. Entretanto, sua natureza determinística e miope limita sua capacidade em grafos densos ou quase regulares, onde decisões locais têm grandes impactos globais.


\subsection{Algoritmo Guloso Randomizado}
\label{subSecAlgRand}

O algoritmo guloso randomizado, baseado em GRASP (Greedy Randomized Adaptive Search Procedure), emprega uma metaheurística ao combinar algoritmos construtivos gulosos randomizados com busca local, introduzindo aleatoriedade na fase de construção de solução candidadata através de uma Lista Restrita de Candidatos (RCL). Para gerar esta lista, calcula-se a menor cor possível para cada vértice não colorido no grafo. Nesse conjunto de candidatos, o GRASP constrói a RCL utilizando o parâmetro $\alpha$, que controla a aleatoriedade: quando é 0, apenas candidatos com a menor cor possível entram na RCL (e consequentemente o algoritmo é guloso); quando é 1, todos os candidatos entram na RCL (algoritmo aleatório). A RCL inclui candidatos cuja cor cumpre o seguinte requisito: $$ cor <= c_{min} + \alpha * \\(c_{max} - c_{min}),$$ onde $c_{min}$ e $c_{max}$ são, respectivamente, a menor e maior cor entre todos os candidatos.
O método empregado executa múltiplas iterações independentes da construção gulosa randomizada. Cada iteração pode produzir uma solução diferente devido à aleatoriedade na seleção da RCL. O algoritmo mantém a melhor solução encontrada ao longo de todas as iterações, onde "melhor" significa usar a menor cor máxima. O número mínimo de iterações é fixado em 30 (requisito da professora) para garantir exploração suficiente do espaço de soluções, apesar de aumentar significantemente o tempo de execução do GRASP em grafos grandes.


\begin{algorithm}[H]
\caption{Algoritmo GRASP para L(p,q)-Coloring}
\label{algGRASP}
\KwIn{Grafo \( G = (V, E) \), \( \alpha \in [0,1] \), parâmetros \( p, q \), número de iterações \( maxIter \)}
\KwOut{Melhor coloração válida \( c^* \)}

\( c^* \leftarrow \emptyset \)\\
\( span^* \leftarrow \infty \)\\

\For{\( iter \leftarrow 1 \) \KwTo \( maxIter \)}{
    \( c \leftarrow \text{ConstruçãoGulosaRandomizada}(G, p, q, \alpha) \)\\
    \( span \leftarrow \max_{v \in V} c(v) \)\\
    
    \If{\( span < span^* \)}{
        \( c^* \leftarrow c \)\\
        \( span^* \leftarrow span \)\\
    }
}

\Return{\( c^* \)}

\vspace{0.5cm}

\SetKwProg{Fn}{Function}{:}{}
\Fn{\text{ConstruçãoGulosaRandomizada}\( (G, p, q, \alpha) \)}{
    Inicialize \( c(v) \leftarrow 0 \) para todo vértice \( v \in V \)\\
    \( V_{coloridos} \leftarrow \emptyset \)\\
    
    \While{\( V_{coloridos} \neq V \)}{
        \( candidatos \leftarrow \emptyset \)\\
        
        \tcp{Avaliação de cada vértice não colorido}
        \For{vértice \( v \in V \setminus V_{coloridos} \)}{
            \( cor_{min} \leftarrow \text{MenorCorVálida}(v, c, p, q) \)\\
            \( candidatos \leftarrow candidatos \cup \{(v, cor_{min})\} \)\\
        }
        
        \tcp{Construção da Lista Restrita de Candidatos (RCL)}
        \( c_{min} \leftarrow \min_{(v,cor) \in candidatos} cor \)\\
        \( c_{max} \leftarrow \max_{(v,cor) \in candidatos} cor \)\\
        \( threshold \leftarrow c_{min} + \alpha \cdot (c_{max} - c_{min}) \)\\
        
        \( RCL \leftarrow \{(v, cor) \in candidatos : cor \leq threshold\} \)\\
        
        \tcp{Seleção aleatoriezada da RCL}
        \( (v_{escolhido}, cor_{escolhida}) \leftarrow \text{random}(RCL) \)\\
        \( c(v_{escolhido}) \leftarrow cor_{escolhida} \)\\
        \( V_{coloridos} \leftarrow V_{coloridos} \cup \{v_{escolhido}\} \)\\
    }
    
    \Return{\( c \)}
}
\end{algorithm}

A abordagem GRASP oferece grande vantagem sobre a abordagem gulosa determinística dado tempo suficiente, pois após algumas iterações, é possível obter soluções significantemente melhores do que o guloso puro, especialmente quando um valor ótimo de $\alpha$ é conhecido para o tipo de grafo em questão. Porém, essa dependência de $\alpha$ é a principal limitação do GRASP, visto que o desempenho pode variar drasticamente em alterações de $\alpha$, podendo performar pior do que um algoritmo guloso determinístico em alguns casos. Logo, a calibração manual do parâmetro também é uma desvantagem. Ainda, esta abordagem possui convergência lenta para grafos grandes, visto que a complexidade assintótica do algoritimo é $O(n^{2})$, tornando o tempo um proibitivo dessa abordagem. Porém, como as execuções do algoritmo são independentes, esse processo pode ser paralelizado. Ainda, o algoritimo guloso randomizado é efetivo quando é necessário descobrir um conjunto diverso de soluções.

Em resumo, o GRASP oferece um equilíbrio entre qualidade da solução e recurso computacional quando o parâmetro $\alpha$ é adequadamente calibrado. É ideal para conjuntos homogêneos de instâncias onde pode-se determinar empiricamente um bom valor de $\alpha$. Sua principal limitação é a necessidade dessa calibração manual e a falta de aprendizado entre iterações.


\subsection{Algoritmo Guloso Randomizado Reativo}
\label{subSecAlgRandReact}
O algoritmo guloso randomizado reativo, ou ReactiveGRASP, é uma adaptação do GRASP explicado anteriormente. A escolha do parâmetro $\alpha$ pode ser um pouco problemática, por isso emprega-se técnicas para avaliar a eficiência do algoritmo durante a execução, a fim de alterar o valor de $\alpha$ a cada bloco de iterações. O algoritmo trabalha com um conjunto de valores alpha candidatos e aprende qual funciona melhor para a instância específica.
O método desenvolvido organiza a execução em blocos de iterações em que seleciona valores $\alpha$ de acordo com probabilidades que refletem seu desempenho passado. Para selecionar $\alpha$, gera-se um número aleatório entre 0 e 1 e percorre as probabilidades acumuladas até encontrar o $\alpha$ "sorteado". Maiores valores de $\alpha$ implicam em probabilidade maior de serem selecionados, mas todos mantêm devem ter chance não-nula, a fim de garantir exploração contínua. Após a construção de cada solução, calculamos um feedback baseada na qualidade da solução através da fórmula:
\begin{equation}
    AlphaReward = \frac{1}{maxColor};
\end{equation} somada para o alpha que gerou a solução, assim cores máximas menores (melhores soluções) geram recompensas maiores. Ao final de cada bloco, as recompensas médias são calculadas (soma das recompensas dividida pelo número de usos) e redistribui-se as probabilidades proporcionalmente às recompensas, selecionando $\alpha$ mais efetivos.

A abordagem ReactiveGRASP resolve o maior problema do GRASP tradicional, a calibração do parâmetro $\alpha$, ao implementar um aprendizado entre os blocos de iterações. Essa característica permite também que o algoritimo seja eficiente em um conjunto de instâncias bem distintas, descobrindo valores suficientemente bons de $\alpha$ durante a execução, o que é particularmente importante quando não se conhece um valor ideal para o conjunto dado, ou quando não há tempo ou incentivo para realizar experimentos para descobrí-lo. Quando é necessário computar muitas iterações sobre os grafos dados, o custo de atualizar as probabilidades de $\alpha$ são amortizados e compensados pelo aprendizado acumulado. Também é eficiente devido à adaptação durante a execução, como em grafos não-uniformes, com regiões mais densas e outras mais esparsas, ou quando uma exploração mais gulosa ($\alpha$ pequeno) é melhor no início para estabelecer uma boa estrutura base, mas uma exploração mais aleatória ($\alpha$ grande) ajuda posteriormente a superar mínimos locais e o caráter miope da abordagem gulosa.

Porém, há grande custo computacional em executar vários blocos até achar valores relativamente bons de $\alpha$, e não se elimina a necessidade de calibração manual, visto que ainda é necessário escolher valores para os parâmetros, como os valores iniciais do conjunto de $\alpha$, e o tamanho dos blocos. Se um dos valores iniciais de $\alpha$ é "sortudo", sua probabilidade aumenta muito no começo da execução e pode ocorrer uma convergência prematura para este valor, mesmo que não seja o melhor valor a longo prazo; e o tamnho do bloco afeta diretamente essa convergência, visto que blocos menores atualizam mais rápido os parâmetros, mesmo se não houver informação suficiente, e blocos maiores ignoram boas soluções encontradas recentemente e tem adaptação demorada, atrasando a convergência. Sendo assim, para grafos pequenos, um algoritimo guloso determinístico ou um GRASP com boa escolha de $\alpha$ são suficientes e o overhead computacional do ReactiveGRASP não é justificado. Ademais, definir a função de recompensa adequada para as instâncias dadas também é uma tarefa problemática, pois o comportamento do algoritmo muda radicalmente para funções diferentes. Recompensas como $AlphaReward = \frac{1}{maxColor^{2}}$ premiam mais grandes melhorias e penalizam mais $\alpha$ considerados inadequados, por exemplo.

Em resumo, o GRASP Reativo elimina a necessidade de calibração manual de $\alpha$, adaptando-se automaticamente a cada instância. É particularmente vantajoso para conjuntos heterogêneos de instâncias ou quando não se tem conhecimento prévio sobre qual configuração funciona melhor. O custo é um overhead computacional adicional considerável e a introdução de novos meta-parâmetros (conjunto de $\alpha$, tamanho de bloco).

\begin{algorithm}[H]
\caption{Algoritmo GRASP Reativo para L(p,q)-Coloring}
\label{algGRASPReativo}
\KwIn{Grafo \( G = (V, E) \), parâmetros \( p, q \), conjunto de alphas \( A = \{\alpha_1, \ldots, \alpha_m\} \), tamanho do bloco \( B \), iterações totais \( maxIter \)}
\KwOut{Melhor coloração válida \( c^* \)}

\( c^* \leftarrow \emptyset \)\\
\( span^* \leftarrow \infty \)\\
\( prob[\alpha_i] \leftarrow \frac{1}{m} \) para \( i = 1, \ldots, m \)\\
\( recompensa[\alpha_i] \leftarrow 0 \) para \( i = 1, \ldots, m \)\\
\( uso[\alpha_i] \leftarrow 0 \) para \( i = 1, \ldots, m \)\\

\For{\( iter \leftarrow 1 \) \KwTo \( maxIter \)}{
    \tcp{Atualize as probabilidades a cada bloco \(B)\)}
    \If{\( iter > 1 \) \textbf{and} \( iter \bmod B = 1 \)}{
        \For{\( i \leftarrow 1 \) \KwTo \( m \)}{
            \If{\( uso[\alpha_i] > 0 \)}{
                \( reward[\alpha_i] \leftarrow \frac{recompensa[\alpha_i]}{uso[\alpha_i]} \)\\
            }
            \Else{
                \( reward[\alpha_i] \leftarrow 0 \)\\
            }
        }
        
        \( soma \leftarrow \sum_{i=1}^{m} reward[\alpha_i] \)\\
        
        \If{\( soma > 0 \)}{
            \For{\( i \leftarrow 1 \) \KwTo \( m \)}{
                \( prob[\alpha_i] \leftarrow \frac{reward[\alpha_i]}{soma} \)\\
            }
        }
        \Else{
            \( prob[\alpha_i] \leftarrow \frac{1}{m} \) para todo \( i \)\\
        }
    }
    
    \tcp{Seleção de  $\alpha$ baseado nas probabilidades}
    \( \alpha_{escolhido} \leftarrow \text{SelecionarAlpha}(A, prob) \)\\
    
    \tcp{Construir solução com $\alpha_{escolhido}$}
    \( c \leftarrow \text{ConstruçãoGulosRandomizada}(G, p, q, \alpha_{escolhido}) \)\\
    \( span \leftarrow \max_{v \in V} c(v) \)\\
    
    \tcp{Atualização de recompensas proporcionalmente ao span}
    \( recompensa[\alpha_{escolhido}] \leftarrow recompensa[\alpha_{escolhido}] + \frac{1}{span} \)\\
    \( uso[\alpha_{escolhido}] \leftarrow uso[\alpha_{escolhido}] + 1 \)\\
    
    \tcp{Atualização da melhor solução até então}
    \If{\( span < span^* \)}{
        \( c^* \leftarrow c \)\\
        \( span^* \leftarrow span \)\\
        \( \alpha^* \leftarrow \alpha_{escolhido} \)\\
    }
}

\Return{\( c^* \)}

\vspace{0.5cm}

\SetKwProg{Fn}{Function}{:}{}
\Fn{\text{SelecionarAlpha}\( (A, prob) \)}{
    \( r \leftarrow \text{random}([0,1]) \)\\
    \( acumulado \leftarrow 0 \)\\
    
    \For{\( i \leftarrow 1 \) \KwTo \( m \)}{
        \( acumulado \leftarrow acumulado + prob[\alpha_i] \)\\
        \If{\( r \leq acumulado \)}{
            \Return{\( \alpha_i \)}
        }
    }
    
    \Return{\( \alpha_m \)}
}
\end{algorithm}

\begin{figure}[ht]
\centering
\resizebox{0.5\textwidth}{!}{
    \input{img/diagramaFluxo}
}
\caption{Exemplo imagem}
\label{fig:fluxograma}
\end{figure}

\textbf{Além do} pseudocódigo, você também pode acrescentar uma figura com um fluxograma, como na Figura \ref{fig:fluxograma}.




%=======================================================
%                 E X P E R I M E N T O S 
%=======================================================
\label{secExperimentos}
\section{Experimentos computacionais}
\label{secResultados}
Nesta seção você deve descrever todo o experimento computacional. Para tanto, defina subseções.

\subsection{Descrição das instâncias}
\label{subSecInstancias}
Descreva as instâncias citando a referência onde as mesmas foram obtidas, se você testou apenas um subconjunto de instâncias da referência, explique qual(is) o(s) critério(s) utilizado(s) para a seleção do conjunto de instâncias usadas. Você pode listar as instâncias em uma tabela como no exemplo da Tabela \ref{tabInstancias}. E note que para o seu problema não necessariamente você terá todas essas colunas.

\begin{table}[!h]
\centering
\caption{Exemplo de tabela com descrição das instâncias}
\begin{tabular}{|l|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{\textbf{Instância}} & \multicolumn{1}{c|}{\textbf{Núm Arestas}} & \multicolumn{1}{c|}{\textbf{Núm Vértices}} & \multicolumn{1}{c|}{\textbf{$K$}} & \multicolumn{1}{c|}{\textbf{$L$}}  \\ \hline
st323\_70a & 323 & 70 & 14 & 9   \\ \hline
proB789\_100a & 789 & 100 & 20 & 10  \\ \hline
lin884\_318 & 884 & 118 & 64 & 10   \\ \hline \hline
pcb2208\_442 & 2.208  & 442 & 89 & 10  \\ \hline
pr5314 & 5.314 & 439 & 88 & 10  \\ \hline
wath4180 & 4.180 & 699 & 20 & 25\\ \hline
lin41817\_710 & 41.817 & 710 & 21 & 25  \\ \hline \hline
kro121002 & 121.002 & 1.000 & 120 & 25  \\ \hline
dilc & 91.217 & 2.620 & 153 & 250  \\ \hline
pro789\_100a & 117.890 & 3.200 & 200 & 107  \\ \hline
\end{tabular}
\label{tabInstancias}
\end{table}


\subsection{Ambiente computacional e  parâmetros}
\label{subSecAmbiente}
Descreva o ambiente computacional utilizado citando a linguagem de programação, o compilador utilizado, o processador da máquina utilizada nos testes, o gerador de números aleatórios etc).

Descreva o conjunto de parâmetros usado (número de iterações, valores de $\alpha$ utilizados nos testes com o algoritmo guloso randomizado, a faixa de valores de $\alpha$ e o tamanho do bloco de atualização das probabilidades adotados no algoritmo guloso randomizado reativo etc. 

\subsection{Resultados obtidos}
\label{subSecResultados}

Apresente aqui os resultados quanto à qualidade (valor da função de otimização). Explique o significado das colunas da tabela. Lembre-se de pôr em negrito os valores associados aos melhores resultados para cada instância. A Tabela \ref{tabResultExemplo} é um exemplo de apresentação dos resultados.

\begin{table}[htbp]
\centering
\caption{Resultados comparativos da melhor solução alcançada por cada algoritmo — diferença percentual em relação à melhor solução conhecida}
\renewcommand{\arraystretch}{1.2}
{
\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\textbf{Instância} & \textbf{Melhor} & \textbf{Literatura} & \textbf{Guloso} & \multicolumn{3}{c|}{\textbf{Randomizado}} & \textbf{Reativo} \\ \cline{5-7}
 & & & &  \multicolumn{1}{c|}{{\bf 0,10}} & \multicolumn{1}{c|}{{\bf 0,30}} & \multicolumn{1}{c|}{{\bf 0,50}} & \\
\hline
I1 & 100 & \textbf{0,00} & 0,20 & 0,07 &  0,12 & \textbf{0,00} & 0,01 \\
I2 & 184 & 0,12 & \textbf{0,00} & 0,21 & 0,28 & 0,20 & \textbf{0,00} \\
\vdots & \vdots & \vdots & \vdots  & \vdots & \vdots & \vdots & \vdots \\
I10 &  &  &  &  &  &  &  \\
\hline
\textbf{Média} &  &  &  &  &  &  &  \\
\hline
\end{tabular}
}
\label{tabResultExemplo}
\end{table}

Segue um exemplo superficial de análise de resultados a partir de uma tabela:

Analisando a Tabela \ref{tabResultExemplo} é possível verificar que os resultados quanto à qualidade da solução apresentados pelo algoritmo proposto em sua fase de construção são melhores que aqueles obtidos pelo algoritmo da literatura. Isto vem a confirmar a hipótese de que o processo realizado pelo algoritmo através da identificação das componentes conexas do grafo, de fato, impacta na qualidade da alocação de canais com menor interferência.

[\textit{Outro exemplo}] A Tabela \ref{tabResultExemplo} mostra que, em relação à qualidade da solução, os algoritmos propostos não foram capazes de alcançar os resultados da literatura. Entretanto, comparando-se os resultados obtidos pelos algoritmos implementados, é possível perceber que o algoritmo Randomizado Reativo obteve um desempenho superior em 90\% das instâncias, especialmente nas instâncias compostas por grafos densos (observe que para imprimir \% é necessário usar uma barra invertida antes).

\colorbox{pink}{
\begin{minipage}[c]{13cm}
[\textbf{Nota}:] Nesta seção você precisa descrever os resultados, não apenas apresentar as tabelas. Procure destacar quais os melhores algoritmos, destacar se há alguma característica de uma ou mais instâncias (tamanho da instância, densidade de arestas ou grupo de instância específico) que esteja influenciando o comportamento de um ou outro algoritmo etc. 
\end{minipage} }

Além da Tabela \ref{tabResultExemplo} (que deve apresentar o desvio percentual dos melhores resultados alcançados por cada algoritmo), uma tabela semelhante deve ser utilizada para apresentar o desvio percentual da média dos resultados alcançados por cada algoritmo. Isso é, na Tabela \ref{tabResultExemplo}, o valor da melhor solução alcançada é utilizado para calcular os desvios e, na Tabela \ref{tabResultExemplo2}, a média do valor da solução obtido nas 10 execuções do algoritmo deve ser utilizada nos cálculos do desvio percentual.


\begin{table}[htbp]
\centering
\caption{Resultados comparativos da média das soluções alcançadas nas 10 execuções de cada algoritmo — diferença percentual em relação à melhor solução conhecida}
\renewcommand{\arraystretch}{1.2}
{
\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\textbf{Instância} & \textbf{Melhor} & \textbf{Guloso} & \multicolumn{3}{c|}{\textbf{Randomizado}} & \textbf{Reativo} \\ \cline{4-6}
 & & &  \multicolumn{1}{c|}{{\bf 0,10}} & \multicolumn{1}{c|}{{\bf 0,30}} & \multicolumn{1}{c|}{{\bf 0,50}} & \\
\hline
I1 & 100 & 0,20 & 0,07 &  0,12 & \textbf{0,00} & 0,01 \\
I2 & 184 & \textbf{0,00} & 0,21 &  0,28 & 0,20 & \textbf{0,00} \\
\vdots & \vdots & \vdots &  \vdots & \vdots & \vdots & \vdots \\
I10 &  &  &  &  &  &  \\
\hline
\textbf{Média} &  &  &  &  &  &  \\
\hline
\end{tabular}
}
\label{tabResultExemplo2}
\end{table}


A Tabela \ref{tabResultExemplo} e a Tabela \ref{tabResultExemplo2} são semelhantes, mas a Tabela \ref{tabResultExemplo} contém a coluna \textbf{Literatura}, que foi omitida na  Tabela \ref{tabResultExemplo2}. Utilize apenas a primeira, caso contenha resultados de algum trabalho da literatura para o seu problema. Caso não tenha resultados da literatura, utilize apenas o modelo da  Tabela \ref{tabResultExemplo2}.

Inclua ainda uma outra tabela com os dados  referentes ao tempo de processamento dos algoritmos. 


\begin{table}[htbp]
\centering
\caption{Tempo médio de execução de cada algoritmo (em seg)}
\renewcommand{\arraystretch}{1.2}
{
\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{Instância} & \textbf{Guloso} & \multicolumn{3}{c|}{\textbf{Randomizado}} & \textbf{Reativo} \\ \cline{3-5}
 & &  \multicolumn{1}{c|}{{\bf 0,10}} & \multicolumn{1}{c|}{{\bf 0,30}} & \multicolumn{1}{c|}{{\bf 0,50}} & \\
\hline
I1 & 0,20 & 0,07 &  0,12 & 0,19 & 0,52 \\
I1 & 0,27 & 0,09 &  0,18 & 0,25 & 1,49 \\
\vdots &  \vdots & \vdots & \vdots & \vdots &  \vdots \\
I10 &  &  &  &  &  \\
\hline
\textbf{Média} &  &  &  &  &  \\
\hline
\end{tabular}
}
\label{tabResultTempo}
\end{table}

Lembre-se que é necessário analisar os dados de cada uma das tabelas!

%=======================================================
%                 C O N C L U S Õ E S
%=======================================================
\section{Conclusões}
\label{secConclusoes}

Apresente aqui as conclusões do trabalho. Comece descrevendo um resumo sucinto do que consistiu o trabalho, o problema modelado em grafos, o que foi implementado. Se tiver sugestões de melhorias para os algoritmos propostos, apresente aqui. Apresente também as principais dificuldades encontradas durante a realização do trabalho 2.



%=======================================================
%             R E F E R Ê N C I A S
%=======================================================
% Incluindo referências bibliográficas
% ATENCAO: as referências incluidas no arquivo bibliografia.bib só aparecem no documento quando efetivamente citadas no texto.
\bibliographystyle{plain} %define o estilo    
\bibliography{bibliografia} %busca o arquivo


\end{document}
